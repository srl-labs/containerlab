package cmd

import (
	"context"
	"fmt"
	"io"
	"strings"
	"time"

	"github.com/charmbracelet/log"

	containertypes "github.com/docker/docker/api/types/container"
	imagetypes "github.com/docker/docker/api/types/image"
	networktypes "github.com/docker/docker/api/types/network"
	"github.com/docker/docker/client"
	"github.com/spf13/cobra"
	"github.com/srl-labs/containerlab/cmd/common"
)

const (
	sshxDefaultNetwork    = "clab"
	sshxContainerImage    = "ghcr.io/srl-labs/network-multitool:latest"
	sshxContainerBaseName = "clab-sshx"
	sshxOutputFile        = "/tmp/sshx_url"
)

var (
	sshxNetwork string
)

// sshxCmd represents the base command for sshx tooling.
var sshxCmd = &cobra.Command{
	Use:   "sshx",
	Short: "Manage sshx containers for collaborative lab access",
}

// sshxAttachCmd represents the command to attach an sshx container.
var sshxAttachCmd = &cobra.Command{
	Use:   "attach",
	Short: "Attach an sshx container to a docker network",
	RunE:  sshxAttachRunE,
	Long: `Attaches a container running sshx to a specified Docker network (default: 'clab').

This allows sharing terminal access to the lab environment via a web link generated by sshx.io.
The container runs 'ghcr.io/srl-labs/network-multitool' and executes sshx, printing the access URL.`,
}

// sshxDetachCmd represents the command to detach an sshx container.
var sshxDetachCmd = &cobra.Command{
	Use:   "detach",
	Short: "Detach (stop and remove) the sshx container from a docker network",
	RunE:  sshxDetachRunE,
	Long: `Stops and removes the sshx container previously attached to the specified Docker network (default: 'clab').
	`,
}

// generateSshxContainerName creates a predictable name for the sshx container.
func generateSshxContainerName(networkName string) string {
	// Sanitize network name slightly for use in container name
	safeNetworkName := strings.ReplaceAll(networkName, "/", "-")
	safeNetworkName = strings.ReplaceAll(safeNetworkName, "_", "-")
	return fmt.Sprintf("%s-%s", sshxContainerBaseName, safeNetworkName)
}

// sshxAttachRunE is the execution function for the attach command.
func sshxAttachRunE(_ *cobra.Command, _ []string) error {
	log.Infof("Attaching sshx container to network '%s'...", sshxNetwork)

	ctx, cancel := context.WithTimeout(context.Background(), common.Timeout)
	defer cancel()

	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		return fmt.Errorf("failed to create docker client: %w", err)
	}
	defer cli.Close()

	contName := generateSshxContainerName(sshxNetwork)

	// Check if container already exists
	_, err = cli.ContainerInspect(ctx, contName)
	if err == nil {
		log.Warnf("Container '%s' already exists. Use 'detach' first if you want to recreate it.", contName)
		return nil
	}
	if !client.IsErrNotFound(err) {
		return fmt.Errorf("failed to inspect container '%s': %w", contName, err)
	}

	// Ensure image is available locally
	log.Debugf("Pulling image %s...", sshxContainerImage)
	reader, err := cli.ImagePull(ctx, sshxContainerImage, imagetypes.PullOptions{})
	if err != nil {
		log.Warnf("Failed to pull image %s (will try to run anyway): %v", sshxContainerImage, err)
	} else {
		_, _ = io.Copy(io.Discard, reader)
		reader.Close()
		log.Debugf("Image %s pulled or already present.", sshxContainerImage)
	}

	// Command to run inside the container
	cmd := []string{
		"sh", "-c",
		fmt.Sprintf(`echo 'Installing sshx...' && curl -sSf https://sshx.io/get | sh > /dev/null && echo 'Starting sshx...' && sshx -q --enable-readers > %s & \
             echo 'Waiting for sshx URL...' && while [ ! -s %s ]; do sleep 1; done && echo 'sshx URL:' && cat %s && sleep infinity`,
			sshxOutputFile, sshxOutputFile, sshxOutputFile),
	}

	log.Debugf("Creating container '%s' with image '%s' on network '%s'", contName, sshxContainerImage, sshxNetwork)
	// Use containertypes and networktypes
	resp, err := cli.ContainerCreate(ctx,
		&containertypes.Config{
			Image: sshxContainerImage,
			Cmd:   cmd,
			Tty:   false,
		},
		&containertypes.HostConfig{
			NetworkMode: containertypes.NetworkMode(sshxNetwork),
			AutoRemove:  false,
		},
		&networktypes.NetworkingConfig{}, nil, // Platform is nil
		contName)
	if err != nil {
		if strings.Contains(err.Error(), "network not found") {
			return fmt.Errorf("docker network '%s' not found. Ensure the lab network exists", sshxNetwork)
		}
		return fmt.Errorf("failed to create container '%s': %w", contName, err)
	}

	log.Debugf("Starting container '%s' (%s)...", contName, resp.ID)
	if err := cli.ContainerStart(ctx, resp.ID, containertypes.StartOptions{}); err != nil {
		// Use containertypes.RemoveOptions from api/types/container
		_ = cli.ContainerRemove(context.Background(), resp.ID, containertypes.RemoveOptions{Force: true})
		return fmt.Errorf("failed to start container '%s': %w", contName, err)
	}

	log.Infof("Container '%s' started. Waiting for sshx URL...", contName)

	time.Sleep(5 * time.Second) // Give sshx some time to start

	// Use containertypes.LogsOptions from api/types/container
	logOpts := containertypes.LogsOptions{
		ShowStdout: true,
		ShowStderr: true,
		Follow:     false,
		Tail:       "20",
	}
	logReader, err := cli.ContainerLogs(ctx, resp.ID, logOpts)
	if err != nil {
		log.Warnf("Failed to get logs for container '%s': %v. Check logs manually using 'docker logs %s'", contName, err, contName)
		return nil
	}
	defer logReader.Close()

	logOutput, err := io.ReadAll(logReader)
	if err != nil {
		log.Warnf("Failed to read logs for container '%s': %v. Check logs manually using 'docker logs %s'", contName, err, contName)
		return nil
	}

	// Try to find the URL in the logs
	logLines := strings.Split(string(logOutput), "\n")
	urlFound := false
	fmt.Println("--- SSHX Access ---")
	for i := len(logLines) - 1; i >= 0; i-- {
		line := logLines[i]
		if len(line) > 8 && (line[0] == 0x01 || line[0] == 0x02) {
			line = line[8:]
		}
		trimmedLine := strings.TrimSpace(line)
		if strings.HasPrefix(trimmedLine, "https://sshx.io/s/") {
			fmt.Printf("Found URL: %s\n", trimmedLine)
			urlFound = true
			break
		}
	}
	if !urlFound {
		fmt.Printf("Could not automatically find the sshx URL in recent logs.\nCheck the full logs: docker logs %s\n", contName)
	}
	fmt.Println("-------------------")
	log.Infof("sshx container '%s' is running. Use 'detach' command to remove it.", contName)

	return nil
}

// sshxDetachRunE is the execution function for the detach command.
func sshxDetachRunE(_ *cobra.Command, _ []string) error {
	log.Infof("Detaching sshx container from network '%s'...", sshxNetwork)

	ctx, cancel := context.WithTimeout(context.Background(), common.Timeout)
	defer cancel()

	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		return fmt.Errorf("failed to create docker client: %w", err)
	}
	defer cli.Close()

	contName := generateSshxContainerName(sshxNetwork)

	log.Debugf("Checking for container '%s'...", contName)
	_, err = cli.ContainerInspect(ctx, contName)
	if err != nil {
		if client.IsErrNotFound(err) {
			log.Infof("Container '%s' not found. Nothing to detach.", contName)
			return nil
		}
		return fmt.Errorf("failed to inspect container '%s': %w", contName, err)
	}

	log.Infof("Stopping container '%s'...", contName)
	stopTimeoutDuration := 10 * time.Second
	stopTimeoutSeconds := int(stopTimeoutDuration.Seconds())
	if err := cli.ContainerStop(ctx, contName, containertypes.StopOptions{Timeout: &stopTimeoutSeconds}); err != nil {
		log.Warnf("Failed to stop container '%s' gracefully (will force remove): %v", contName, err)
	} else {
		log.Debugf("Container '%s' stopped.", contName)
	}

	log.Infof("Removing container '%s'...", contName)
	removeOptions := containertypes.RemoveOptions{
		Force: true,
	}
	if err := cli.ContainerRemove(ctx, contName, removeOptions); err != nil {
		return fmt.Errorf("failed to remove container '%s': %w", contName, err)
	}

	log.Infof("Successfully detached and removed sshx container '%s'.", contName)
	return nil
}

func init() {
	toolsCmd.AddCommand(sshxCmd)

	sshxCmd.AddCommand(sshxAttachCmd)
	sshxCmd.AddCommand(sshxDetachCmd)

	sshxCmd.PersistentFlags().StringVarP(&sshxNetwork, "network", "n", sshxDefaultNetwork, "Docker network to attach/detach the sshx container to/from")

}
